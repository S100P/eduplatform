# Как работают JwtAuthenticationFilter и AuthorizationFilter в Spring Security

Это не опасно и является правильным, стандартным способом построения таких фильтров. Давайте разберем, почему это безопасно и логично, используя аналогию с пропускным пунктом.

Представьте, что Spring Security — это многоуровневый пропускной пункт в здание.

### 1. `JwtAuthenticationFilter` — это первый охранник

*   **Его задача:** Проверить, есть ли у посетителя специальный пропуск (JWT-токен). Если пропуск есть и он действителен, охранник ставит посетителю "временную отметку" (заполняет `SecurityContextHolder`), что "этот человек проверен".
*   **`shouldNotFilter` — это инструкция для этого охранника.** Она говорит: "Если видишь, что человек идет в общедоступную столовую (например, на `/api/v1/auth/register`), не трать время на проверку его спецпропуска. Просто пропусти его к следующему посту".

### 2. `AuthorizationFilter` — это второй, главный охранник на этаже

*   **Его задача:** Проверить, в какую именно комнату идет посетитель (на какой URL), и свериться со своим списком правил (`SecurityConfig`).
*   **`requestMatchers(...).permitAll()` — это запись в его списке.** Она говорит: "Вход в столовую (`/api/v1/auth/register`) разрешен **всем**, неважно, есть у них "временная отметка" или нет".
*   **`.anyRequest().authenticated()` — это другая запись.** Она говорит: "Для входа во все остальные комнаты (например, в кабинет директора `/api/v1/users`) обязательно требуется "временная отметка" от первого охранника".

---

## Как это работает вместе (пошагово)

#### Сценарий 1: Запрос на публичный URL `/api/v1/auth/register`

1.  Запрос приходит на **первый пост (`JwtAuthenticationFilter`)**.
2.  Охранник смотрит на путь и видит инструкцию `shouldNotFilter`. Он **ничего не делает** и просто пропускает посетителя дальше. `SecurityContext` остается пустым.
3.  Запрос доходит до **второго поста (`AuthorizationFilter`)**.
4.  Охранник смотрит на путь (`/api/v1/auth/register`) и на свой список правил. Правило гласит: `permitAll()`.
5.  **Результат:** Доступ разрешен. Все безопасно.

#### Сценарий 2: Запрос на защищенный URL `/api/v1/users` без токена

1.  Запрос приходит на **первый пост (`JwtAuthenticationFilter`)**.
2.  Охранник смотрит на путь, `shouldNotFilter` возвращает `false`. Он пытается найти спецпропуск (JWT), не находит его и **ничего не делает**, пропуская посетителя дальше. `SecurityContext` остается пустым.
3.  Запрос доходит до **второго поста (`AuthorizationFilter`)**.
4.  Охранник смотрит на путь (`/api/v1/users`) и на правило `.anyRequest().authenticated()`. Правило требует "временную отметку".
5.  Он проверяет посетителя и видит, что отметки нет (`SecurityContext` пуст).
6.  **Результат:** Доступ запрещен (ошибка 401). Все безопасно.

---

## Почему это не "дыра" в безопасности?

Потому что `shouldNotFilter` **не дает доступ**. Он всего лишь **отключает один конкретный фильтр** (ваш `JwtAuthenticationFilter`) для определенных путей.

Решение о доступе принимает **другой фильтр** (`AuthorizationFilter`), который работает позже и руководствуется **главным источником правды** — вашим `SecurityConfig` и правилами `permitAll()` / `authenticated()`.

### Зачем тогда вообще нужен `shouldNotFilter`?

Это **оптимизация**. Мы просто не выполняем лишнюю работу (поиск и парсинг заголовка `Authorization`) для тех запросов, где токена заведомо быть не должно. Это делает систему чуть более производительной и логику чище.

**Итог:** Вы не создаете уязвимость. Вы создаете два уровня проверки:
1.  **Аутентификация** (`JwtAuthenticationFilter`): "Кто ты?" (отвечает на этот вопрос, если есть токен).
2.  **Авторизация** (`AuthorizationFilter`): "Что тебе можно?" (отвечает на этот вопрос на основе правил из `SecurityConfig`).

Использование `shouldNotFilter` — это грамотное разделение ответственности между этими уровнями.
