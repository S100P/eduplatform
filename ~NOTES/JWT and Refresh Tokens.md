# Как связаны JWT и Refresh-токены?

Это отличный вопрос, и он затрагивает самую суть механики access и refresh токенов. Здесь есть важное различие, которое нужно прояснить:

**Refresh-токен не проверяет JWT-токен. У них совершенно разные и независимые задачи.**

Они не "общаются" и не "понимают" друг друга. Это два разных ключа, которые клиент использует на разных этапах.

Давайте представим это как проход в здание:

*   **Access Token (JWT)** — это ваш одноразовый пропуск в конкретный кабинет (например, `/api/users`). Он действует короткое время (например, 1 час). Охранник (ваше API) смотрит на пропуск, видит, что он не просрочен и подпись не подделана, и пропускает вас. Ему не нужно звонить на ресепшен, чтобы проверить вас.
*   **Refresh Token** — это ваша долгосрочная карта-ключ от самого здания. Вы не показываете ее каждому охраннику. Вы используете ее только на ресепшене, когда ваш одноразовый пропуск в кабинет просрочился.

### Как это работает на самом деле (по шагам):

1.  **Первоначальный вход (логин и пароль)**
    *   Пользователь вводит логин и пароль.
    *   Сервер проверяет их.
    *   Если все верно, сервер создает **сразу два токена**:
        *   Короткоживущий **Access Token (JWT)**.
        *   Долгоживущий **Refresh Token** (который сохраняется в вашей базе данных через `RefreshTokenService`).
    *   Сервер отправляет **оба токена** клиенту (в браузер или мобильное приложение).

2.  **Работа с приложением**
    *   Клиент хочет получить какие-то данные (например, свой профиль).
    *   Он отправляет запрос на сервер, прикрепляя к нему **Access Token (JWT)** в заголовке `Authorization`.
    *   Сервер (ваше API) получает запрос, проверяет подпись и срок действия JWT. Это очень быстрая операция, не требующая обращения к базе данных. Если JWT в порядке — сервер отдает данные.

3.  **Access Token протухает**
    *   Проходит час. Клиент снова отправляет запрос с тем же **Access Token (JWT)**.
    *   Сервер видит, что токен просрочен, и отвечает ошибкой `401 Unauthorized`.

4.  **Магия Refresh Token'а (вот ответ на ваш вопрос)**
    *   Клиент, получив ошибку `401`, **не просит пользователя снова вводить логин и пароль**.
    *   Вместо этого он находит у себя сохраненный **Refresh Token**.
    *   Клиент отправляет специальный запрос на отдельный эндпоинт (например, `/api/auth/refresh`), и в теле этого запроса передает свой **Refresh Token**.
    *   Сервер получает этот запрос:
        *   Он берет строку refresh-токена.
        *   Идет в базу данных (с помощью вашего `RefreshTokenService.validateAndGetToken`) и ищет токен с таким значением.
        *   Проверяет: существует ли он? Не отозван ли (`isRevoked`)? Не истек ли его срок действия (`expiresAt`)?
        *   **Если все проверки в базе данных прошли успешно**, сервер понимает: "Ага, это легитимный пользователь, его сессия еще действительна".
        *   Только после этой проверки сервер создает **совершенно новую пару токенов**: новый Access Token и новый Refresh Token.
        *   Он отправляет эту новую пару клиенту.

5.  **Продолжение работы**
    *   Клиент получает новые токены, сохраняет их и автоматически повторяет тот запрос, который не удался в шаге 3, но уже с **новым Access Token (JWT)**.
    *   Запрос успешно выполняется.

### Итог:

Refresh-токен **не знает** о JWT. Его единственная задача — быть "доказательством" для сервера, что пользователь все еще аутентифицирован, чтобы сервер мог выдать **новый** JWT, когда старый истечет. Это позволяет пользователям оставаться в системе неделями, не вводя пароль каждый час, и при этом сохранять безопасность, так как сам JWT (который передается с каждым запросом) живет очень недолго.