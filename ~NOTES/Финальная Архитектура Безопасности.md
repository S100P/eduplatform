# Финальная Архитектура Безопасности: Детальный Обзор

Эта архитектура построена на **двухконтурной модели безопасности** и **принципе нулевого доверия (Zero Trust)**.

*   **Внешний контур:** Обеспечивает аутентификацию **клиентов** (браузер, мобильное приложение). Использует **асимметричное шифрование (RSA)** для JWT, что является самым безопасным подходом.
*   **Внутренний контур:** Обеспечивает аутентификацию **между сервисами** (`api-gateway` -> `user-service`). Использует **симметричное шифрование (HMAC)**, что является самым быстрым и эффективным подходом для внутренней коммуникации.

---

## Компонент 1: `user-service` — Центр Идентификации (Token Issuer)

Его главная роль — **управлять пользователями и быть единственным источником правды об их личности**. Только он имеет право создавать и подписывать JWT.

### Ключевые классы и их роли:

1.  **`JwtService.java`**
    *   **Что делает:** Генерирует JWT для пользователей после успешного логина.
    *   **Как делает:** Использует **приватный RSA-ключ** (`jwt.rsa.private-key` из `application.yml`) для подписи токена по алгоритму **RS256**.
    *   **Чего НЕ делает:** Он больше не занимается валидацией или чтением токенов. Его единственная задача — создание.

2.  **`JwksController.java` и `JwksService.java`**
    *   **Что делают:** Публикуют **публичный RSA-ключ** в стандартном формате JWKS (JSON Web Key Set).
    *   **Как делают:** Создают публичный эндпоинт `/.well-known/jwks.json`. `JwksService` читает `jwt.rsa.public-key` из `application.yml` и преобразует его в JSON-структуру с помощью библиотеки `nimbus-jose-jwt`.
    *   **Зачем это нужно:** Это механизм **автоматического обнаружения ключей**. Он позволяет `api-gateway` (и любым другим сервисам) получать публичный ключ для проверки JWT, не имея прямого доступа к конфигурации `user-service`. Это полностью разделяет "издателя" и "проверяющего".

3.  **`HeaderAuthenticationFilter.java`**
    *   **Что делает:** Является **второй линией обороны**. Проверяет, что запрос, пришедший в `user-service`, действительно был обработан и авторизован нашим `api-gateway`.
    *   **Как делает:**
        1.  Читает внутренние заголовки `X-Auth-*`.
        2.  Проверяет срок жизни по `X-Auth-Exp`.
        3.  Используя общий секрет `internal-secret`, пересчитывает **HMAC-подпись** и сравнивает ее с подписью в `X-Auth-Signature`.
        4.  Только если подпись верна, он заполняет `SecurityContext` данными о пользователе, позволяя ему доступ к защищенным методам контроллера.

4.  **`SecurityConfig.java`**
    *   **Что делает:** Связывает все воедино.
    *   **Как делает:**
        1.  Разрешает публичный доступ к эндпоинтам аутентификации (`/api/v1/auth/**`) и к эндпоинту с ключами (`/.well-known/jwks.json`).
        2.  Добавляет `HeaderAuthenticationFilter` в цепочку безопасности, чтобы он проверял каждый защищенный запрос.

---

## Компонент 2: `api-gateway` — Пограничный Контроль (Gatekeeper)

Его главная роль — **быть единой точкой входа, проверять подлинность каждого запроса от клиента и защищать внутренние сервисы**.

### Ключевые классы и их роли:

1.  **`JwtUtil.java`**
    *   **Что делает:** Проверяет JWT, присланный клиентом.
    *   **Как делает:**
        1.  Использует библиотеку `nimbus-jose-jwt` и ее компонент `RemoteJWKSet`.
        2.  При старте (и периодически) он асинхронно обращается к `user-service` по адресу `jwt.jwks-uri` и загружает публичный ключ.
        3.  Для каждого входящего JWT он использует этот **публичный ключ** для проверки подписи по алгоритму **RS256**.
    *   **Чего НЕ делает:** Он не знает и не хранит никаких секретов для подписи JWT. Он только проверяет.

2.  **`AuthenticationFilter.java`**
    *   **Что делает:** Это главный "рабочий" фильтр шлюза. Он выполняет всю логику после успешной проверки JWT.
    *   **Как делает (пошагово):**
        1.  Вызывает `JwtUtil` для проверки JWT от клиента. Если JWT невалиден, запрос немедленно отклоняется с ошибкой 401.
        2.  **Очищает (экранирует) заголовки:** Полностью удаляет из запроса любые входящие заголовки `X-Auth-*` или `X-User-*`, чтобы предотвратить их подделку клиентом.
        3.  **Создает внутренние заголовки:** Извлекает из проверенного JWT `id` и `roles` пользователя.
        4.  **Подписывает внутренние заголовки:** Формирует строку из `id`, `roles` и срока жизни, а затем создает для нее **HMAC-подпись**, используя `internal-secret`.
        5.  **Обогащает запрос:** Добавляет в запрос, идущий к микросервису, очищенный набор заголовков: `X-Auth-User`, `X-Auth-Roles`, `X-Auth-Exp` и `X-Auth-Signature`.

3.  **`SecurityConfig.java`**
    *   **Что делает:** Отключает стандартную, "навязчивую" защиту Spring Security.
    *   **Как делает:** Явно разрешает все запросы (`.anyExchange().permitAll()`), чтобы они могли дойти до фильтров Spring Cloud Gateway (таких как наш `AuthenticationFilter`), которые уже сами принимают решение о безопасности.

---

### Схема Работы: Жизненный Цикл Запроса к Защищенному Ресурсу

1.  **Клиент -> API Gateway**
    *   Клиент отправляет запрос `GET /api/v1/users/me` с заголовком `Authorization: Bearer <JWT>`.

2.  **Внутри API Gateway (Внешний контур)**
    *   `AuthenticationFilter` перехватывает запрос.
    *   `JwtUtil` берет токен, обращается (из кеша) к публичному ключу, полученному от `user-service`, и **проверяет RSA-подпись токена**.
    *   Проверка успешна.
    *   `AuthenticationFilter` удаляет все "лишние" заголовки.
    *   `AuthenticationFilter` извлекает из JWT `id` и `roles`, создает HMAC-подпись с помощью `internal-secret` и добавляет в запрос заголовки `X-Auth-*`.

3.  **API Gateway -> User-Service**
    *   Шлюз отправляет измененный запрос в `user-service`. В нем больше нет `Authorization` заголовка, но есть подписанные `X-Auth-*` заголовки.

4.  **Внутри User-Service (Внутренний контур)**
    *   `HeaderAuthenticationFilter` перехватывает запрос.
    *   Он видит `X-Auth-*` заголовки.
    *   Он пересчитывает HMAC-подпись, используя тот же `internal-secret`, и **сравнивает ее с подписью в `X-Auth-Signature`**.
    *   Проверка успешна.
    *   Фильтр создает `Authentication` объект с `id` и `roles` и помещает его в `SecurityContext`.
    *   Запрос доходит до `AuthController`, который безопасно извлекает `id` пользователя из `SecurityContext` и выполняет свою бизнес-логику.

5.  **User-Service -> API Gateway -> Клиент**
    *   `user-service` возвращает успешный ответ, который проксируется через шлюз обратно клиенту.

Эта двухэтапная проверка гарантирует максимальную безопасность: никто, кроме `user-service`, не может создать валидный JWT, и никто, кроме `api-gateway`, не может создать валидный запрос к внутренним сервисам.
