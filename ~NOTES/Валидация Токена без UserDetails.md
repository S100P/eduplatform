# Валидация токена без UserDetails

Этот метод — полная противоположность методу, использующему `UserDetails`, по своей задаче. Понимание их различий — ключ к пониманию всей системы безопасности.

### Как он работает? (Техническая сторона)

Этот метод — это, по сути, "детектор подделок" для JWT. Его единственная задача — ответить на вопрос: **"Этот токен был выдан нашей системой, он не был изменен и его срок действия не истек?"**

Он делает это с помощью одной ключевой операции: `Jwts.parserBuilder()...parseClaimsJws(authToken)`.

Эта одна строчка кода под капотом выполняет **сразу три критически важные проверки**:

1.  **Проверка подписи (Signature Validation):**
    *   Токен состоит из трех частей: `header.payload.signature`.
    *   Библиотека берет `header` и `payload`, применяет тот же алгоритм хеширования с секретным ключом (`getSignKey()`) и сравнивает полученный результат с `signature` из токена.
    *   **Если они не совпадают** — значит, токен был изменен (подделан). Библиотека выбрасывает исключение `SecurityException` или `MalformedJwtException`.

2.  **Проверка формата (Format Validation):**
    *   Библиотека проверяет, является ли строка вообще JWT-токеном (состоит из трех частей, разделенных точками, и т.д.).
    *   Если нет — выбрасывается `MalformedJwtException` или `IllegalArgumentException`.

3.  **Проверка срока жизни (Expiration Validation):**
    *   Библиотека смотрит на стандартное поле `exp` (expiration time) внутри `payload`.
    *   Она сравнивает это время с текущим временем на сервере.
    *   **Если время `exp` уже в прошлом** — значит, токен просрочен. Библиотека выбрасывает исключение `ExpiredJwtException`.

Весь метод построен на этой логике:
*   **`try`**: Попытаться разобрать (спарсить) токен. Если все три проверки выше проходят успешно, парсинг завершается без ошибок, и метод возвращает `true`.
*   **`catch`**: Если **любая** из этих проверок проваливается, библиотека выбрасывает соответствующее исключение. Метод ловит его, логирует ошибку и возвращает `false`.

### Для чего он нужен и где применяется?

Этот метод используется, когда вам нужно проверить **подлинность самого токена**, но вам еще **не важен или неизвестен конкретный пользователь**.

Это своего рода **предварительная, "санитарная" проверка**.

**Основной сценарий применения — выход из системы (Logout).**

Представьте, что пользователь нажимает "Выйти".
1.  Клиентское приложение отправляет на сервер запрос на `/api/auth/logout`, прикрепляя свой JWT.
2.  Сервер должен добавить этот токен в "черный список" (например, в Redis или `TokenBlacklistService`), чтобы им нельзя было воспользоваться снова до истечения срока его действия.
3.  **Но перед тем, как добавить токен в черный список**, сервер должен убедиться, что это не какой-то мусор, а настоящий, валидный токен. Зачем хранить в черном списке подделки?
4.  Вот здесь и вызывается `validateToken(authToken)`. Он быстро проверяет:
    *   Это наш токен? (проверка подписи)
    *   Он еще не истек? (проверка `exp`)
    *   Он не сломан? (проверка формата)
5.  Если метод возвращает `true`, значит, токен подлинный, и его можно смело добавлять в черный список. Обратите внимание: на этом этапе нам **не нужно было обращаться к базе данных** за `UserDetails`, что делает операцию очень быстрой.

### Ключевое отличие от `validateToken(..., UserDetails userDetails)`

Давайте подытожим разницу с помощью аналогии с пропуском в здание:

*   `validateToken(String token)`
    *   **Что делает:** Проверяет, что пропуск не поддельный (есть водяные знаки, голограмма), не просрочен и не порван.
    *   **Отвечает на вопрос:** "Это вообще легальный пропуск?"

*   `validateToken(String token, UserDetails userDetails)`
    *   **Что делает:** Проверяет все то же самое, **ПЛЮС** сверяет фотографию на пропуске с лицом человека, который его предъявляет.
    *   **Отвечает на вопрос:** "Это легальный пропуск, **и** он принадлежит именно этому человеку?"

Поэтому в `JwtAuthenticationFilter` вы используете второй, более строгий метод, потому что там вам нужно не просто проверить токен, а **аутентифицировать конкретного пользователя** и убедиться, что он — это он.
